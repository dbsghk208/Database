

- EXIST

 EXIST 안의 조건이 **존재**해야만 전체 결과를 출력해라 라는 의미!!

```
ex)  
SELECT 칼럼1, 칼럼2  
FROM table_Name  
WHERE EXIST (SELECT  FROM  WHERE username =”홍길동” );  
```

→ EXIST 안에 홍길동이라는 이름을 가진 사람이 존재하면  
칼럼1, 칼럼2 전체적인 결과를 반환한다.  
만약 tempTable  홍길동이라는 사람이 없으면 결과는 나오지 않는다.  
<br><br>

- NOT EXIST

NOT EXIST 안의 조건이  **존재하지 않을때만** 전체 결과를 출력해라 라는 의미!

```
ex)  
SELECT 칼럼1, 칼럼2  
FROM table_Name  
WHERE NOT EXIST (SELECT  FROM  WHERE username =”홍길동” );  
```

→ NOT EXIST 안에 홍길동이라는 이름을 가진 사람이 존재하지 않으면  
칼럼1, 칼럼2 전체적인 결과를 반환한다.  
만약 tempTable  홍길동이라는 사람이 있으면 결과는 나오지 않는다.  
<br><br><br>


### 집합연산자의 종류

| 집합연산자 | 연산자의 의미 |
| --- | --- |
| UNION | 여러개의 SQL 문의 결과에 대한 합집하으로 결과에서 모든 중복된 행은 하나의 행으로 만든다. |
| UNOIN ALL | 여러개의 SQL 문의 결과에 대한 합집합으로 중복된 행동 그대로 결과로 표시된다.  즉, 단순히 결과만 합쳐놓은것.  일반적으로 여러 질의 결과가 상호 배타적인 일때 많이 사용된다.  개별 SQL문의 결과가 서로 중복되지 않는 경우,UNION 과 결과가 동일하다.  (결과의 정렬 순서에는 차이가 있을 수 있음)   |
| INTERSECT | 여러 개의 SQL 문의 결과에 대한 교집합니다. 중복된 행은 하나의 행으로 만든다. |
| EXCEPT | 앞의 SQL 문 결과에 대한 차집합.  중복된 행은 하나의 행으로 만든다.  (일부 데이터베이스는 MINUS를 사용함) |


<br><br><br>


- 테이블에 계층형 데이터가 존재하는경우 데이터를 조회하기 위해서는 계층형 질의를 사용한다.  
- 계층형 데이터란 ?   
테이블에 계층적으로 상위와 하위 데이터가 포함되 데이터를 말함  
예를 들어 사원 테이블에서는 사원들 사이에   
 상위 사원(관리자)과 하위 사원 관계가 존재하고  
조직 테이블에서는 조직들 사이에 상위 조직과 하위 조직 관계가 존재한다.  
<br><br>

- 집계그룹함수  
ROLLUP,  CUBE, GROUPING SETS

> **CUBE**
> 

: 결합 가능한 모든 값에 대하여 다차원 집계를 생성함  
 결과에 대한 정렬이 필요한 경우 ORDER BY 절에 명시적으로 정렬칼럼이 표시 되어야 함  
 다른 그룹함수에 비해 시스템에 대한 부하다 크다.  
<br><br>

- SELF JOIN  
동일 테이블 사이의 조인.

FROM 절에 동일 테이블이 두번 이상 나타남.  
동일 테이블 사이의  조인을 수행하면 테이블과 칼럼 이름이 모두 동일하기 때문에   
식별을 위해 반드시 테이블 별칭(Alias) 를 사용한다.  
<br>

ex) 

```sql
SELECT 
	ALIAS명1.칼럼명,
	ALIAS명2.칼럼명,... 
FROM
	테이블 ALIAS명1,
	테이블 ALIAS명2
WHERE ALIAS명1.칼럼명2 = ALIAS명2.칼럼명1 
;
```
<br><br>
 

- **비교연산자**

&nbsp; 단일행 비교연산자  
&nbsp; = < ≤ > ≥ <>

&nbsp; 다중행 비교연산자  
&nbsp; IN  ANY  ALL  SOME  EXISTS

단일행 서브쿼리 비교연산자는 다중행 서브쿼리의 비교연산자로 사용할수 없다.  
그 반대의 경우는 가능함
<br><br>

- 인라인 뷰(Inline  view)  
**from 절에 사용되는 서브쿼리를 인라인 뷰**라고 한다.  
서브쿼리의 결과가 마치 실행 시에 동적으로 생성된 테이블인 것처럼 사용할 수 있다.  
인라인뷰는 SQL 문이 실행될 때만 임시적으로 생성되는 동적인 뷰이기 때문에  
데이터베이스에 해당 정보가 저장되지 않음  
<br><br><br><br>


**순위를 구하는 함수로는 RANK , DENSE_RANK , ROW_NUMBER  함수**  

- Rank 함수  
ORDER BY  포함한  QUERY 문에서 특정 항목(칼럼) 에 대한   
순위를 구하는 함수이며  
**동일한 값에 대해서는 동일한 순위를 부여하게 된다.**  
    

- DENSE_RANK  
함수는 RANK 함수와 흡사하나,  
**동일한 순위를 하나의 건수로 취급하는 것이 다른 점이다.**  
<br><br>    

<세개의 함수 차이점>  

- RANK  
동일 값에 대해서는 동일 순위를 부여하고 
중간 순위는 비워둔다.

- DENSE_RANK  
동일 값에 대해서는 동일 순위를 부여하고  
중간순위를 비우지 않는다.  

- ROW_NUMBER  
동일 값에 대해서도 유일한 순위를 부여한다.  
<br><br><br><br>


- **WINDOW 함수**

SQL의 윈도우 함수란 행과 행 간을 비교, 연산, 정의하기 위한 함수이다.  
분석함수 또는 순위함수라고 하기도 한다.  
다른 함수들처럼 중첩해서 사용할 수는 없지만 서브쿼리에서는 사용가능하다.  
<br><br><br>

**WINDOW FUNCTION 기본 문법**  

윈도우 함수에는 OVER 문구가 필수로 들어간다.  

```
SELECT WINDOW_FUNCTION (ARGUMENTS) 
OVER([PARTITION BY 컬럼] [ORDER BY 컬럼] [WINDOWING 절])
FROM 테이블명;
```

| 구분 | 함수 | 비교 |
| --- | --- | --- |
| 순위 함수 | RANK, DENSE_RANK, ROW_NUMBER |  |
| 일반 집계 함수 | SUM, MAX, MIN, AVG, COUNT | SQL서버에서는 OVER 절 내에서 ORDER BY 지원하지 않음 |
| 그룹 내 행 순서 함수 | FIRST_VALUE, LAST_VALUE, LAG, LEAD | SQL서버에서는 지원하지 않음 |
| 그룹 내 비율 함수 | RATIO_TO_REPROT, PERCENT_RANK, CUME_DIST, NTILE | NTILE 제외 SQL서버에서는 지원하지 않음 |

<br><br>

참조사이트  
https://for-my-wealthy-life.tistory.com/48
<br><br><br>


# JOIN

참조사이트  
[https://hoon93.tistory.com/46](https://hoon93.tistory.com/46)

> NL Join (Nested Loops Join) 수행 원리  
> 
1) 다음은 NL Join 의 수행 방식을 단계별로 나타냅니다.  

![Untitled (1)](https://user-images.githubusercontent.com/89206108/168478856-b03beec5-d9d2-475f-9cca-d09b21044a22.png)

 

```

1) 선행 테이블에서 조건을 만족하는 첫 번째 행을 찾음 
 -> 이때 선행 테이블에 주어진 조건을 만족하지 않은 경우 해당 데이터는 필터링 된다.
2) 선행 테이블의 조인 키를 가지고 후행 테이블에 조인 키가 존재하는지 찾으러 감 -> 조인시도 
3) 후행 테이블의 인덱스에 선행 테이블의 조인 키가 존재하는지 확인 
 -> 선행 테이블의 조인 값이 후행테이블에 존재하지 않으면 선행 테이블 데이터는 필터링됨
    (더 이상 조인 작업을 진행할 필요없음)
4) 인덱스에서 추출한 레코드 식별자를 이용하여 후행테이블 엑세스 
 -> 후행 테이블에 주어진 조건까지 모두 만족하면 해당 행을 추출버퍼에 넣음.

5) ~ 11) 앞의 작업을 반복 수행.
```
<br><br>

- NL Join 의 가장 큰 특징은 랜덤 액세스(Random Access) 방식으로 데이터 읽는다는 것이다.  
그리고 랜덤 액세스의 예로는 인덱스 스캔(Index Scan) 이 있다.  
즉, 인덱스 스캔(Index Scan) 은 NL Join 방식으로 조인을 수행한다.  
추가적으로 대량의 데이터를 랜덤 액세스로 접근하게 되면  
많은 I/O가 발생하여 성능상 좋지 않기 때문에 무조건 랜덤액세스가 좋은게 아님을 인지!  
    

- **NL Join 기법**은 조인이 성공하면 바로 조인 결과를 사용자에게 보여 줌.  
따라서 결과를 **가능한 한 빨리 화면에 보여줘야 하는**   
온라인 프로그램에 적당한 조인 기법이다.  
    
- NL Join 이외의 Sort Merge Join 과 Hash Join 은 조인 칼럼의 인덱스(index) 가  
없어도 사용가능하며, 메모리에 적재할 수 있는 크기보다 더 커지면   
임시 영역(디스크)을 사용한다는 특징이 있다.  
<br><br>

> Sort Merge Join 수행 원리
> 
1) 다음은 Sort Merge Join 의 수행 방식을 단계별로 나타낸것

![Untitled (2)](https://user-images.githubusercontent.com/89206108/168479496-76961aa7-53bf-4ac2-a7e4-a1cd0811826d.png)


```
1) 선행 테이블에서 주어진 조건을 만족하는 행을 찾는다.
2) 해당 행들에 대해서, 선행 테이블의 조인 키(칼럼)를 기준으로 데이터를 정렬.
3) 후행 테이블에서 주어진 조건을 만족하는 행을 찾는다.
4) 해당 행들에 대해서, 후행 테이블의 조인 키(칼럼)를 기준으로 데이터를 정렬
5) Join 을 수행
6) 조인에 성공하면 추출버퍼에 넣는다.
```



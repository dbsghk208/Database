

- EXIST

 EXIST 안의 조건이 **존재**해야만 전체 결과를 출력해라 라는 의미!!

```
ex)  
SELECT 칼럼1, 칼럼2  
FROM table_Name  
WHERE EXIST (SELECT  FROM  WHERE username =”홍길동” );  
```

→ EXIST 안에 홍길동이라는 이름을 가진 사람이 존재하면  
칼럼1, 칼럼2 전체적인 결과를 반환한다.  
만약 tempTable  홍길동이라는 사람이 없으면 결과는 나오지 않는다.  
<br><br>

- NOT EXIST

NOT EXIST 안의 조건이  **존재하지 않을때만** 전체 결과를 출력해라 라는 의미!

```
ex)  
SELECT 칼럼1, 칼럼2  
FROM table_Name  
WHERE NOT EXIST (SELECT  FROM  WHERE username =”홍길동” );  
```

→ NOT EXIST 안에 홍길동이라는 이름을 가진 사람이 존재하지 않으면  
칼럼1, 칼럼2 전체적인 결과를 반환한다.  
만약 tempTable  홍길동이라는 사람이 있으면 결과는 나오지 않는다.  
<br><br><br>


### 집합연산자의 종류

| 집합연산자 | 연산자의 의미 |
| --- | --- |
| UNION | 여러개의 SQL 문의 결과에 대한 합집하으로 결과에서 모든 중복된 행은 하나의 행으로 만든다. |
| UNOIN ALL | 여러개의 SQL 문의 결과에 대한 합집합으로 중복된 행동 그대로 결과로 표시된다.  즉, 단순히 결과만 합쳐놓은것.  일반적으로 여러 질의 결과가 상호 배타적인 일때 많이 사용된다.  개별 SQL문의 결과가 서로 중복되지 않는 경우,UNION 과 결과가 동일하다.  (결과의 정렬 순서에는 차이가 있을 수 있음)   |
| INTERSECT | 여러 개의 SQL 문의 결과에 대한 교집합니다. 중복된 행은 하나의 행으로 만든다. |
| EXCEPT | 앞의 SQL 문 결과에 대한 차집합.  중복된 행은 하나의 행으로 만든다.  (일부 데이터베이스는 MINUS를 사용함) |


<br><br><br>


- 테이블에 계층형 데이터가 존재하는경우 데이터를 조회하기 위해서는 계층형 질의를 사용한다.  
- 계층형 데이터란 ?   
테이블에 계층적으로 상위와 하위 데이터가 포함되 데이터를 말함  
예를 들어 사원 테이블에서는 사원들 사이에   
 상위 사원(관리자)과 하위 사원 관계가 존재하고  
조직 테이블에서는 조직들 사이에 상위 조직과 하위 조직 관계가 존재한다.  
<br><br>

- 집계그룹함수  
ROLLUP,  CUBE, GROUPING SETS

> **CUBE**
> 

: 결합 가능한 모든 값에 대하여 다차원 집계를 생성함  
 결과에 대한 정렬이 필요한 경우 ORDER BY 절에 명시적으로 정렬칼럼이 표시 되어야 함  
 다른 그룹함수에 비해 시스템에 대한 부하다 크다.  
<br><br>

- SELF JOIN  
동일 테이블 사이의 조인.

FROM 절에 동일 테이블이 두번 이상 나타남.  
동일 테이블 사이의  조인을 수행하면 테이블과 칼럼 이름이 모두 동일하기 때문에   
식별을 위해 반드시 테이블 별칭(Alias) 를 사용한다.  
<br>

ex) 

```sql
SELECT 
	ALIAS명1.칼럼명,
	ALIAS명2.칼럼명,... 
FROM
	테이블 ALIAS명1,
	테이블 ALIAS명2
WHERE ALIAS명1.칼럼명2 = ALIAS명2.칼럼명1 
;
```
<br><br>
 

- **비교연산자**

&nbsp; 단일행 비교연산자  
&nbsp; = < ≤ > ≥ <>

&nbsp; 다중행 비교연산자  
&nbsp; IN  ANY  ALL  SOME  EXISTS

단일행 서브쿼리 비교연산자는 다중행 서브쿼리의 비교연산자로 사용할수 없다.  
그 반대의 경우는 가능함
<br><br>

- 인라인 뷰(Inline  view)  
**from 절에 사용되는 서브쿼리를 인라인 뷰**라고 한다.  
서브쿼리의 결과가 마치 실행 시에 동적으로 생성된 테이블인 것처럼 사용할 수 있다.  
인라인뷰는 SQL 문이 실행될 때만 임시적으로 생성되는 동적인 뷰이기 때문에  
데이터베이스에 해당 정보가 저장되지 않음  
<br><br><br><br>


**순위를 구하는 함수로는 RANK , DENSE_RANK , ROW_NUMBER  함수**  

- Rank 함수  
ORDER BY  포함한  QUERY 문에서 특정 항목(칼럼) 에 대한   
순위를 구하는 함수이며  
**동일한 값에 대해서는 동일한 순위를 부여하게 된다.**  
    

- DENSE_RANK  
함수는 RANK 함수와 흡사하나,  
**동일한 순위를 하나의 건수로 취급하는 것이 다른 점이다.**  
<br><br>    

<세개의 함수 차이점>  

- RANK 

동일 값에 대해서는 동일 순위를 부여하고 
중간 순위는 비워둔다.

- DENSE_RANK

중간순위를 비우지 않는다.  

- ROW_NUMBER  
동일 값에 대해서도 유일한 순위를 부여한다.  
<br><br><br><br>


- **WINDOW 함수**

SQL의 윈도우 함수란 행과 행 간을 비교, 연산, 정의하기 위한 함수이다.  
분석함수 또는 순위함수라고 하기도 한다.  
다른 함수들처럼 중첩해서 사용할 수는 없지만 서브쿼리에서는 사용가능하다.  
<br><br><br>

**WINDOW FUNCTION 기본 문법**  

윈도우 함수에는 OVER 문구가 필수로 들어간다.  

```
SELECT WINDOW_FUNCTION (ARGUMENTS) 
OVER([PARTITION BY 컬럼] [ORDER BY 컬럼] [WINDOWING 절])
FROM 테이블명;
```

| 구분 | 함수 | 비교 |
| --- | --- | --- |
| 순위 함수 | RANK, DENSE_RANK, ROW_NUMBER |  |
| 일반 집계 함수 | SUM, MAX, MIN, AVG, COUNT | SQL서버에서는 OVER 절 내에서 ORDER BY 지원하지 않음 |
| 그룹 내 행 순서 함수 | FIRST_VALUE, LAST_VALUE, LAG, LEAD | SQL서버에서는 지원하지 않음 |
| 그룹 내 비율 함수 | RATIO_TO_REPROT, PERCENT_RANK, CUME_DIST, NTILE | NTILE 제외 SQL서버에서는 지원하지 않음 |

<br><br>


https://for-my-wealthy-life.tistory.com/48



